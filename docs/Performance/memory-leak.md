## 内存泄漏

本应该被回收的资源未被回收就会造成内存泄漏。

### V8内存空间

V8内存分代存储

* 新生代空间：空间小，1M~8M之间，大多数的对象存储在这里，分为2个相同的空间FROM和TO
* 老生代指针空间：存储指向其他对象的指针。如果对象在新空间存储时间够长将移到该空间
* 老生代数据空间：存放只包含原始数据的对象，字符串、封箱的数字以及未封箱的双精度数字数组，在新生代中执行GC后还长时间存活的对象将移到该空间
* 大数据空间：数据太大不适合在其他空间存储的将在该空间创建
* 代码空间：存储JS代码经过编译的汇编代码
* Cell空间, property cell空间, map空间: 简化垃圾回收

### V8垃圾回收机制

#### Scavenge

* 在新生代执行
* 执行频率高，速度快，但是清除不完全
* 执行过程
  * 在TO空间装满时执行
  * 交换FROM和TO空间
  * 复制所有存活对象到TO空间（原FROM）或者将存活2次以上的对象复制到老生代空间
  * 清除复制的对象

#### 标记清除、标记压缩

从根节点标记引用到的对象，清除未标记的对象，整理碎片。

相对Scavenge执行频率低、速度慢，但是清除完全。

### 检测工具

#### node-memwatch

[node-memwatch](https://www.npmjs.com/package/node-memwatch)提供检测内存泄漏的方法：

* `leak`事件：当检测到内存泄漏时发送
* `stats`事件：不定期发送，描述内存使用情况和趋势
* `HeapDiff`类：比较2个时间点的内存状态

#### Heapdump

获取内存快照，然后使用Chrome开发工具检查。

#### node-inspector

可以在开发模式连接到正在运行的应用，获取内存数据，进行调试和重编译。

#### node命令

trace_gc：打印垃圾回收日志

```
  node --trace_gc index.js
```

使用`trace_gc`参数启动应用，会打印垃圾回收日志。
expose-gc

### 便于内存调试的编码规范

* 闭包和函数使用命名：便于定位问题
* 避免使用大对象
* 函数应该优化，优化后的函数运行更快、占用内存更少、引起GC的频率更低
* 避免函数的多态（入参类型固定），内联缓存会缓存一些通过对象键访问的数据或简单函数的执行结果，如果函数入参类型变化会导致缓存失效
* 不要在访问大文件时将整个文件读取到内存，可以逐行或分段读取
* 不要阻塞主服务线程
* 不要创建不需要的数据，只在真正需要时创建数据
