## 优化基本技巧

### 文本

#### 将开发与部署分开

开发模式为了调试目的，不会改变代码的大小和可读性。

部署为了优化目的，会压缩代码进而影响可读性。

#### 文本资源最小化

通过删除文本资源的空白和不必要的字符而不改变其有效性或功能来压缩文本资源。

HTML/CSS/JS、包括资源文件都可以压缩。

可以使用构建工具：
* webpack
* gulp
* grunt

#### 压缩文本资源

在服务器使用Gzip自动压缩整个项目。

浏览器支持HTTP请求的Gzip压缩，但必须正确配置服务器，以便在请求时提供压缩资源。

#### 减少库的使用

流行的CSS和JavaScript库尽力缩小和压缩下载文件，但仍然占用大量的下载时间。

如果项目中大量的使用库中功能，只能这样；如果只是使用少量特定方法，可以通过用一次性函数或CSS规则替换这些特性来节省大量的下载时间。

`webpack`中使用`Tree Shaking`的技巧处理这种问题。

### 图片

图片需要比文本更多的时间和带宽才能下载和渲染。 图形内容可轻松占网站总带宽的60％-85％。

#### 删除不必要的图片

3个问题：
* 是否需要这个图片？
* 如果需要，是否需要立即使用，可不可以推迟加载？
* 如果不能推迟加载，是否可以对其进行优化以使其对页面加载的影响最小？

尽量将图片换成图片提供的信息，如果图片没有为用户添加信息价值或澄清意义，请将其删除。

#### 选择合适的图片类型

使用大小最小的图片类型实现同样的效果。

* png：用于剪贴画，线条图或任何需要透明度的地方
* jpg：用于照片
* gif：用于动画

#### 删除图片元数据

元数据存储图片相关信息，包括相机/手机型号、日期和时间戳、姓名、分辨率等。

这些数据对于浏览效果而言并不重要，使用工具将其删除。

#### 调整图片大小

##### 根据预期用途调整图片大小

图片都应根据其预期用途进行适当调整，并且不应依赖浏览器调整其大小以进行渲染。

例如制作单独的、尺寸合适的缩略图，在用户实际请求时才显示完整尺寸的图片。

##### 裁剪图片仅显示重要内容

裁剪：省略图片中对信息传递不重要的部分。

额外的背景和空白，不必要的边框和额外的对象使图片不仅在视觉上而且在物理上混乱，影响图片大小及其下载效率。

##### 降低图片质量

在确定图片尺寸后，使用工具降低图片质量，但仍然保持所需的效果。

#### 压缩图片

使用压缩工具压缩PNG和JPG图片，减小文件大小，但不会影响尺寸或视觉质量。 

### 降低HTTP请求频率

减少页面资源数量可以有效降低HTTP请求次数，但并不意味着省略内容只是使用更有效的构建。

#### 合并文本资源

合并CSS和JS文件减少HTTP请求。

> 注意：
>
> CSS的级联优先级允许后来的规则在没有警告的情况下覆盖之前的规则。合并会存在样式覆盖的问题。
> 解决办法：寻找冲突的规则并确定是否可被取代，或者使用更具体的选择器来正确应用。
>
> JS合并会遇到类似的问题，同名的函数或变量会被覆盖。

#### 合并图片资源

图片合并是将多个小图片组合成一个物理图片文件，然后在页面使用CSS背景定位仅显示所需的图片。

可以应用于任何图片组，最常见的是合并图标之类的小图片。

#### HTTP/2

服务器请求在HTTP/2上更快，因此合并文件以消除请求可能效率不高。

如果将静态与动态的资源合并来减少请求，则可能会强制重新加载资源的静态部分以获取动态部分，从而对缓存有效性产生负面影响。

#### js位置

##### 脚本位置

脚本块放在页头中会阻止页面呈现，解决方案是将脚本引用放在最后，就在body闭合标记之前，这允许浏览器加载和呈现页面内容后下载脚本。

例外情况：任何操作初始内容或DOM的脚本，或在呈现之前或期间提供所需的页面功能。 像这样的关键脚本可以放在一个单独的文件中，并放到页面头加载，其余的仍然可以放在页面的最后加载。

##### 代码位置

将代码内容放在script标签之间可以避免上述问题。

### HTTP缓存

浏览器第一次加载网页时，会将页面资源存储在HTTP缓存中。下次浏览器访问该页面时，可以在缓存中查找以前获取的资源并从磁盘检索它们，通常比从网络下载更快。最大化缓存使用率对于加快回访速度至关重要。

#### 启用缓存

缓存的工作原理是根据页面资源的变化频率进行分类，确认静态资源和动态资源，静态资源适合用于缓存。

浏览器缓存不仅仅是存储在本机上，实际上可能发生在原始服务器和客户端浏览器之间的任何中间站点，例如代理缓存或内容分发网络（CDN）缓存。

#### 缓存HTTP头

两种主要类型的缓存头，`cache-control`和`expires`，定义资源的缓存特征。 `cache-control`比`expires`更现代、更灵活，但两者可以同时使用。

缓存头应用于服务器来设置缓存特征。 通过标识资源或资源类型（例如图像或CSS文件），使用所需的缓存选项指定资源的标头来启用缓存。

##### cache-control

处理缓存的指令：
* no-cache：指定内容可缓存，但是在提供给客户端使用前必须重新验证。强制客户端检查新鲜度，但如果资源未更改，则允许它再次下载资源。与`no-store`互斥。
* no-store：指明不可以用任何方式缓存内容。与`no-cache`互斥。
* public：指明内容可被浏览器和任何中间缓存缓存。覆盖请求中使用HTTP身份验证的默认设置`private`。与`private`互斥。
* private：指定可由览器存储的内容，但不得由任何中间缓存缓存。通常用于特定于用户但不是特别敏感的数据。与`public`互斥。
* max-age：定义从原始服务器重新验证或再次下载之前内容可被缓存的最大时间。此选项通常替换`expires`标头并以秒为单位，最大有效期为一年（31536000秒）。

##### Expires

`expires`设置过期时间。 过了这个时间之后，对内容的请求必须返回到原始服务器。

> 注意
> 
> 同`cache-control`一样，不要使用超过一年的时间，这在互联网上表示永远有效。
